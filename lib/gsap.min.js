// GSAP Animation Library - Minimal Implementation
// This provides basic animation capabilities for the static site

class GSAPAnimation {
    constructor() {
        this.animations = new Map();
        this.timeline = [];
    }
    
    to(target, duration, properties) {
        const element = typeof target === 'string' ? document.querySelector(target) : target;
        
        if (!element) return this;
        
        const startTime = performance.now();
        const startValues = {};
        
        // Get initial values
        Object.keys(properties).forEach(prop => {
            if (prop === 'x' || prop === 'y' || prop === 'z') {
                startValues[prop] = parseFloat(element.style.transform?.match(new RegExp(prop + '\\(([^)]+)\\)'))?.[1] || 0);
            } else if (prop === 'opacity') {
                startValues[prop] = parseFloat(element.style.opacity || 1);
            } else if (prop === 'scale') {
                startValues[prop] = parseFloat(element.style.transform?.match(/scale\\(([^)]+)\\)/)?.[1] || 1);
            }
        });
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / (duration * 1000), 1);
            
            // Apply easing (default ease-out)
            const easedProgress = 1 - Math.pow(1 - progress, 3);
            
            Object.keys(properties).forEach(prop => {
                const startValue = startValues[prop] || 0;
                const endValue = properties[prop];
                const currentValue = startValue + (endValue - startValue) * easedProgress;
                
                if (prop === 'x' || prop === 'y' || prop === 'z') {
                    const transforms = element.style.transform || '';
                    const newTransforms = transforms.replace(new RegExp(prop + '\\([^)]+\\)'), '') + ` translate${prop.toUpperCase()}(${currentValue}px)`;
                    element.style.transform = newTransforms.trim();
                } else if (prop === 'opacity') {
                    element.style.opacity = currentValue;
                } else if (prop === 'scale') {
                    const transforms = element.style.transform || '';
                    const newTransforms = transforms.replace(/scale\([^)]+\)/, '') + ` scale(${currentValue})`;
                    element.style.transform = newTransforms.trim();
                } else {
                    element.style[prop] = currentValue + (typeof properties[prop] === 'number' ? 'px' : '');
                }
            });
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else if (properties.onComplete) {
                properties.onComplete();
            }
        };
        
        requestAnimationFrame(animate);
        return this;
    }
    
    from(target, duration, properties) {
        const element = typeof target === 'string' ? document.querySelector(target) : target;
        
        if (!element) return this;
        
        // Set initial values and animate to current state
        const currentValues = {};
        Object.keys(properties).forEach(prop => {
            if (prop === 'opacity') {
                currentValues[prop] = parseFloat(element.style.opacity || 1);
                element.style.opacity = properties[prop];
            }
        });
        
        return this.to(target, duration, currentValues);
    }
    
    set(target, properties) {
        const element = typeof target === 'string' ? document.querySelector(target) : target;
        
        if (!element) return this;
        
        Object.keys(properties).forEach(prop => {
            if (prop === 'x' || prop === 'y' || prop === 'z') {
                const transforms = element.style.transform || '';
                const newTransforms = transforms.replace(new RegExp(prop + '\\([^)]+\\)'), '') + ` translate${prop.toUpperCase()}(${properties[prop]}px)`;
                element.style.transform = newTransforms.trim();
            } else if (prop === 'opacity') {
                element.style.opacity = properties[prop];
            } else if (prop === 'scale') {
                const transforms = element.style.transform || '';
                const newTransforms = transforms.replace(/scale\([^)]+\)/, '') + ` scale(${properties[prop]})`;
                element.style.transform = newTransforms.trim();
            } else {
                element.style[prop] = properties[prop] + (typeof properties[prop] === 'number' ? 'px' : '');
            }
        });
        
        return this;
    }
    
    timeline() {
        return new GSAPTimeline();
    }
}

class GSAPTimeline {
    constructor() {
        this.animations = [];
    }
    
    to(target, duration, properties) {
        this.animations.push(() => gsap.to(target, duration, properties));
        return this;
    }
    
    from(target, duration, properties) {
        this.animations.push(() => gsap.from(target, duration, properties));
        return this;
    }
    
    play() {
        let delay = 0;
        this.animations.forEach((animation, index) => {
            setTimeout(animation, delay);
            delay += 100; // Small delay between animations
        });
        return this;
    }
}

// Initialize global GSAP instance
const gsap = new GSAPAnimation();

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { gsap, GSAPAnimation, GSAPTimeline };
} else {
    window.gsap = gsap;
    window.GSAPAnimation = GSAPAnimation;
    window.GSAPTimeline = GSAPTimeline;
}